import raylib::*;
import fmt::*;

struct Style {
  foreground:           Color = WHITE,
  background:           Color = BLACK,
  highlighted:          Color = ORANGE,

  line_thickness:       f32 = 2,

  // Text stuff.
  font_size:            s32 = 16,
  font_spacing:         f32 = 1,
  font_color_override:  Option!<Color>,
  font:                 Font,
}

impl Style {
  fn default() -> Style {
    return .{
      foreground: WHITE,
      background: BLACK,
      highlighted: ORANGE,
      font_color_override: Some(GRAY),
      font_size: 16,
      line_thickness: 2,
      font: GetFontDefault(),
    };
  }
}

#flags enum InputState {
  None,
  Hovered,
  Pressed,
  Held,
}

#flags enum WidgetState {
  Inactive, // Completely off.
  Active,   // on.

  Disabled, // Uninteractable.
  Enabled,  // interactable.
}

#static widget_id: u32 = 0;

struct WidgetBase {
  // unique id.
  id:    u32 = widget_id++,
  // Z index.
  layer: u32,
  // various input states
  input_state: InputState = InputState::None,
  // general, option-like states.
  state: WidgetState = WidgetState::Active,
  // the general style of this.
  style: Style,
  // the bounds and position.
  rectangle: Rectangle,
  model_rectangle: Rectangle,

  on_pressed:   fn * (*mut WidgetBase, s32) -> bool,
  on_released:  fn * (*mut WidgetBase, s32) -> bool,
  on_hovered:   fn * (*mut WidgetBase, Vector2),

  children: List!<*mut WidgetBase>,
};

trait Widget {
  fn get_base(*const self) -> *mut WidgetBase {
    return &mut self.base;
  }

  fn is_hovered(*const self) -> bool {
    return (self.get_base().input_state & InputState::Hovered) != 0;
  }

  fn is_pressed(*const self) -> bool {
    return (self.get_base().input_state & InputState::Pressed) != 0;
  }

  fn is_held(*const self) -> bool {
    return (self.get_base().input_state & InputState::Held) != 0;
  }

  fn get_children(*const self) -> *mut List!<dyn Widget>;

  // draw with no stateful logic.
  fn draw(*mut self);

  fn on_window_resized(*mut self, screen: Rectangle) {
    base := self.get_base()

    base.rectangle.x = base.model_rectangle.x * screen.width;
    base.rectangle.y = base.model_rectangle.y * screen.height;
    base.rectangle.width = base.model_rectangle.width * screen.width;
    base.rectangle.height = base.model_rectangle.height * screen.height;

    children := self.get_children();

    if children {
      for child in children.iter_mut() {
        child.on_window_resized(screen);
      }
    }
  }
}

choice Event {
  // dyn Widget field is always sender.
  MouseDown(MouseButton),
  MouseUp(MouseButton),
  MouseMoved(Vector2),
  KeyPressed(KeyboardKey),
}

struct TextField {
  base:         WidgetBase,
  label:        Option!<String>,
  in_edit_mode: bool = false,
  pre_edit_style: Style,
}

impl Widget for TextField {
  fn draw(*mut self) {
    mut position: Vector2 = .{
      x: self.base.rectangle.x,
      y: self.base.rectangle.y
    };

    mut size: Vector2 = .{
      x: self.base.rectangle.width,
      y: self.base.rectangle.height
    };

    DrawRectangleV(position, size, self.base.style.background);

    if self.label is Option!<String>::Some(text) {
      text_width: f32 = MeasureText(text.data, self.base.style.font_size);
      text_height: f32 = self.base.style.font_size;
      
      if text_width > self.base.rectangle.width {
        size.x = text_width;
        position.x = self.base.rectangle.x - (text_width - self.base.rectangle.width) / 2;
      }

      text_position: Vector2 = .{
        x: position.x + (size.x - text_width) / 2,
        y: position.y + (size.y - text_height) / 2,
      };

      draw_text(text, text_position, self.base.style);
    }

    if !self.in_edit_mode && self.base.input_state & InputState::Hovered && IsKeyDown(KeyboardKey::KEY_F2) {
      self.in_edit_mode = true;
      self.pre_edit_style = self.base.style;
      self.base.style.font_color_override = Some(WHITE);
      self.base.style.background = YELLOW.with_alpha(25);
      self.base.style.highlighted = CLEAR;
    }

    if self.in_edit_mode && IsKeyPressed(KeyboardKey::KEY_ENTER) {
      self.in_edit_mode = false;
      self.base.style = self.pre_edit_style;
    }

    if self.in_edit_mode {
      if self.label.is_none() {
        string: String = .{};
        self.label = Some(string);
      }

      ch := GetCharPressed() as u8;
      if IsKeyPressed(KeyboardKey::KEY_BACKSPACE) {
        if self.label is Option!<String>::Some(&mut value) {
          if !value.is_empty() {
            value.pop();
          }
        }
      } else if IsKeyPressed(KeyboardKey::KEY_SPACE) {
        if self.label is Option!<String>::Some(&mut value) {
          value.push(' ');
        }
      } else if ch.is_alpha() || ch.is_ascii_punctuation() {
        if self.label is Option!<String>::Some(&mut value) {
          value.push(ch);
        }
      }
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

struct Slider!<TString, T> where TString: AsByteSlice {
  base:             WidgetBase,
  text:             Option!<TString, >,
  format_options:   Option!<FormatOptions>,

  // is the mouse holding this ish.
  held:             bool,

  // numerical state.
  min_value:        T,
  max_value:        T,
  value:            *mut T,
}

struct CheckButton {
  base:         WidgetBase,
  // A possible label.
  text:         Option!<String>,
  // this has crazy behaviour. it should be removed.
  allow_hold:   bool,
  // is checked or not.
  value:        *mut bool,
}

struct DropDown!<TString, UserArg> where TString: AsByteSlice {
  base:                   WidgetBase,
  // optional label to show in the base rect.
  text:                   Option!<TString>,
  // list of the options that can be selected.
  // maybe this should be a list of widgets.s
  options:                List!<TString>,
  // Some(selected_index), None() none selected.
  selected_index:         Option!<u32>,
  // if this is enabled, the label will prefer the option that's selected, instead of a constant label.
  prefer_selected_option: bool,
  // is currently expanded.
  is_open:                bool,
  // a user arg that's used for the on_selected callback.
  user_arg:               *mut UserArg,
  // called when an option is selected via the dropdown.
  on_option_selected:     fn * (TString, *mut UserArg) -> void,
}

struct Label!<TString> where TString: AsByteSlice {
  base: WidgetBase,
  text: TString,
}

struct ListBox {
  base: WidgetBase,
  children: List!<dyn Widget>,
}

enum RenderHookPriority {
  PreWidgetRender,
  PostWidgetRender
}

struct Window!<Ctx> {
  widgets: List!<dyn Widget>,
  background_color: Color,
  render_hooks: List!<(RenderHookPriority, fn*(*mut Ctx))>,
  init_hooks: List!<fn * (*mut void)>,
  // TODO: when we have default generics, we can have a default stub here. for now, just *mut void.
  user_context: *mut Ctx,
  on_resized_callbacks: List!<(*mut void, fn * (*mut void, Rectangle, Rectangle))>,
  screen_size: Rectangle,
}

impl!<Ctx> Window!<Ctx> {
  alias RenderHook :: fn * (*mut Ctx);

  fn on_resized(*mut self, new_size: Rectangle) {
    for widget in self.widgets.iter_mut() {
      widget.on_window_resized(new_size);
    }
    for arg, callback in self.on_resized_callbacks {
      callback(arg, self.screen_size, new_size);
    }
    self.screen_size = new_size;
  }

  fn new(title: str = "Rayui Window",
        size: Vector2 = .{x: 800, y: 600},
        target_fps: u8 = 60,
        background_color: Color = .{ r:0, g:0, b:0, a:255}) -> #self {
    InitWindow(size.x as s32, size.y as s32, title.data);
    SetTargetFPS(target_fps);
    return .{
      screen_size: .{
        x: 0,
        y: 0,
        width: GetScreenWidth(),
        height: GetScreenHeight(),
      }
      background_color: background_color
    };
  }

  fn run(*mut self) {
    for hook in self.init_hooks {
      hook(self.user_context);
    }

    while !WindowShouldClose() {
      BeginDrawing();
      ClearBackground(self.background_color);

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PreWidgetRender {
          hook(self.user_context);
        }
      }

      self.widgets.sort(fn(widget: *const dyn Widget) -> u32 {
        return widget.get_base().layer;
      });

      {
        mouse_position := GetMousePosition();
        for widget in self.widgets.iter_mut() {
          base := widget.get_base();
          base.input_state = InputState::None;
          if CheckCollisionPointRec(mouse_position, base.rectangle) {
            base.input_state = InputState::Hovered;

            if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
              base.input_state |= InputState::Pressed;
            }
          }

        }
      }

      for widget in self.widgets.iter_mut() {
        widget.draw();
      }

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PostWidgetRender {
          hook(self.user_context);
        }
      }

      EndDrawing();
    }
  }

  fn add_widget!<T>(*mut self, t: *mut T) -> #self where T: Widget  {
    trait_obj := dynof(t, Widget);
    trait_obj.on_window_resized(.{
      x: 0, y: 0,
      width: GetScreenWidth(),
      height: GetScreenHeight(),
    });
    self.widgets.push(trait_obj);

    return *self;
  }

  fn add_render_hook(*mut self, hook: RenderHook, priority: RenderHookPriority = RenderHookPriority::PreWidgetRender) -> #self {
    self.render_hooks.push((priority, hook));
    return *self;
  }

  fn set_user_context(*mut self, ctx: *mut Ctx) -> #self {
    self.user_context = ctx;
    return *self;
  }

  fn add_on_init_hook(*mut self, hook: RenderHook) -> #self {
    self.init_hooks.push(hook);
    return *self;
  }
}

fn draw_textf!<Tuple>(fmt: str, tuple: Tuple, position: Vector2, style: Style, format_options: FormatOptions) where Tuple: IsTuple {
  text := format(fmt, tuple, format_options);
  defer {
    text.deinit();
  }

  DrawTextEx(
    style.font,
    text.data,
    position,
    style.font_size,
    style.font_spacing,
    style.font_color_override.or_else(style.foreground)
  );
}

fn draw_text!<Data>(text: Data, position: Vector2, style: Style) where Data: AsByteSlice {
  DrawTextEx(
    style.font,
    text.as_byte_slice().data,
    position,
    style.font_size,
    style.font_spacing,
    style.font_color_override.or_else(style.foreground)
  );
}

// for drawing a single char. useful for custom text layouts.
fn draw_character(char: u8, position: Vector2, style: Style) {
  temp : u8[2] = .[char, '\0' as u8];
  slice := Slice!<u8>.{data: temp, length: 1};
  draw_text!<Slice!<u8>>(slice, position, style);
}

impl Widget for ListBox {
  fn draw(*mut self) {
    DrawRectangleRec(self.base.rectangle, self.base.style.background.with_alpha(20));
    DrawRectangleLinesEx(self.base.rectangle, self.base.style.line_thickness, self.base.style.background);
    const MARGIN := 10.0;
    position: Vector2 = .{ x: self.base.rectangle.x, y: self.base.rectangle.y  };
    for child in self.children.iter_mut() {
      base := child.get_base();
      rect := &mut base.rectangle;
      rect.x = position.x + (MARGIN / 2);
      rect.y = position.y + (MARGIN / 2);
      rect.width = self.base.rectangle.width - MARGIN;
      rect.height = (self.base.rectangle.height / self.children.length as f32) - MARGIN;
      position.y += rect.height + MARGIN / 2;
      child.draw();
    }
  }
  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return &mut self.children;
  }
}

impl ListBox {
  fn add_child!<T>(*mut self, widget: *mut T) where T: Widget {
    self.base.children.push(widget.get_base());
    self.children.push(dynof(widget, Widget));
  }
}

impl!<TString, T> Widget for Slider!<TString, T> where TString: AsByteSlice, T: IsNumeric {
  fn draw(*mut self) {
    // Draw the slider background
    DrawRectangleRec(
      self.base.rectangle,
      self.base.style.background,
    );

    v_f := (*self.value) as f32;
    min_f := self.min_value as f32;
    max_f := self.max_value as f32;

    slider_width: f32 = self.base.rectangle.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);

    slider_rect: Rectangle = .{
      x: self.base.rectangle.x,
      y: self.base.rectangle.y,
      width: slider_width,
      height: self.base.rectangle.height
    };

    DrawRectangleRec(slider_rect, self.base.style.foreground);

    DrawRectangleLinesEx(
      self.base.rectangle,
      self.base.style.line_thickness,
      self.base.style.foreground
    );

    mut font_color: Color = self.base.style.font_color_override.or_else(self.base.style.foreground);

    mut text_position: Vector2 = .{ x: self.base.rectangle.x, y: self.base.rectangle.y };

    if self.text.is_some() {
      the_text := self.text.unwrap();

      text_position = .{
        x: (self.base.rectangle.x - 15 + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };

      draw_text(
        the_text,
        text_position,
        self.base.style,
      );
    }

    mut options: FormatOptions;
    if self.format_options.is_some() {
      options = self.format_options.unwrap();
    } else {
      options = *FormatOptions::current();
    }

    mut value_text := format("%", (*self.value,), options);
    defer {
      value_text.deinit();
    }

    // 10 pixels padding
    text_position = .{
      x: text_position.x + 30 + MeasureText(value_text.data, self.base.style.font_size),
      y: text_position.y,
    };

    draw_text(value_text, text_position, self.base.style);

    // Update logic
    mut increment: T;
    if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
      increment = (self.max_value - self.min_value) / 100;
    } else {
      increment = (self.max_value - self.min_value) / 50;
    }

    if IsKeyPressed(KeyboardKey::KEY_RIGHT) {
      *self.value = clamp(*self.value + increment, self.min_value, self.max_value);
    } else if IsKeyPressed(KeyboardKey::KEY_LEFT) {
      *self.value = clamp(*self.value - increment, self.min_value, self.max_value);
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();

    if CheckCollisionPointRec(mouse_pos, self.base.rectangle) {
      if IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = true;
      }
    }

    if self.held {
      if !IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = false;
      } else {
        new_value := self.min_value + ((mouse_pos.x - self.base.rectangle.x) / self.base.rectangle.width) * (self.max_value - self.min_value);
        *self.value = clamp(new_value, min(self.min_value, self.max_value), max(self.min_value, self.max_value));
      }
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}


/*
  Draws a check button, one that is stateful-- it stores whether it's 'on' or 'off'. a toggle button.

  NOTE:
    the 'allow_hold' parameter has significant effect on the behaviour of the button.

    if it is false:
      clicking once will toggle the button on (LMB).
      clicking it again, will toggle it off   (LMB).
      holding the button has no effect.

    if it is true:
      clicking the button will toggle the button on (LMB).
      mousing over the button while (LMB) is held down will toggle it on.
      clicking the button again, will toggle the button off (RMB)
      mousing over the button while (RMB) is held down will toggle it off.

    It's very likely you'd never utilize the 'allow_hold: true' behaviour, unless you're creating some grid of buttons,
    where you want to quickly enable large ranges of them, or disable them alike. (such as the 'sequencer' project).

    perhaps we should remove this, but this is where this widget came from, and it was neccesary there.
*/
impl Widget for CheckButton {
  fn draw(*mut self) {
    if *self.value {
      DrawRectangleRec(
        self.base.rectangle,
        self.base.style.highlighted
      );
    } else {
      DrawRectangleRec(self.base.rectangle, self.base.style.background);
    }

    if self.text.is_some() {
      the_text := self.text.unwrap();
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(the_text, text_position, self.base.style);
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.base.rectangle);

    if hit {
      DrawRectangleLinesEx(
        self.base.rectangle,
        self.base.style.line_thickness,
        ORANGE
      );
    }

    mut left := false;
    mut right := false;

    if self.allow_hold {
      left = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT);
      right = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_RIGHT);
      if hit && left {
        *self.value = true;
      } else if hit && right {
        *self.value = false;
      }
    } else if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      *self.value = !*self.value;
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

/*
  'prefer_selected_option'
    will prefer presenting the string value of the selected option when one is selected, over the label.
*/
impl!<TString, UserArg> Widget for DropDown!<TString, UserArg> where TString: AsByteSlice {
  fn draw(*mut self) {
    // Draw the DropDown box
    DrawRectangleRec(self.base.rectangle, self.base.style.background);

    // Draw the selected option, instead of the label text.
    if self.selected_index.is_some() && (self.text.is_none() || self.prefer_selected_option) {
      the_text := self.options[self.selected_index.unwrap()];
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(
        the_text,
        text_position,
        self.base.style
      );
    } else if self.text.is_some() {
      the_text := self.text.unwrap();
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(
        the_text,
        text_position,
        self.base.style
      );
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.base.rectangle);

    if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      self.is_open = !self.is_open;
    }

    mut hit_option := false;
    if self.is_open {
      // copy for mutating.
      mut option_rect: Rectangle = self.base.rectangle;
      option_rect.y += self.base.rectangle.height;

      for i in 0..self.options.length {
        mut option_color := self.base.style.background;
        hit := CheckCollisionPointRec(GetMousePosition(), option_rect);
        if hit {
          option_color = self.base.style.highlighted;
          hit_option = true;
        }

        DrawRectangleRec(option_rect, option_color);

        text := self.options[i].as_byte_slice();
        text_position: Vector2 = .{
          x: option_rect.x + (option_rect.width - MeasureText(text.data, self.base.style.font_size)) / 2,
          y: option_rect.y + (option_rect.height - self.base.style.font_size) / 2,
        };

        draw_text(text, text_position, self.base.style);

        if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
          self.selected_index = Some(i as u32);
          self.is_open = false;
          if self.on_option_selected {
            self.on_option_selected(self.options[i], self.user_arg);
          }
        }

        option_rect.y += option_rect.height;
      }
    }

    if !hit && !hit_option {
      self.is_open = false;
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}
