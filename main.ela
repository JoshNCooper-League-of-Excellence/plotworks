
#include "ui.ela"

import fmt::*;

struct Node;
struct Operation;

struct Context {
  nodes: List!<Node>,
  operations: List!<Operation>,

  node_list_ui: *mut ListBox,
  freeform_area: *mut FreeformArea,
  node_list_button_style: Style,
  font: Font,
}
mut gContext: Context;

fn nodespace_to_screen(node_value: Vector2) -> Vector2 {
  rect := gContext.freeform_area.base.rectangle;
  return Vector2.{
    x: rect.x + node_value.x * rect.width,
    y: rect.y + node_value.y * rect.height,
  };
}

fn screen_to_nodespace(screen_pos: Vector2) -> Vector2 {
  rect := gContext.freeform_area.base.rectangle;
  return Vector2.{
    x: (screen_pos.x - rect.x) / rect.width,
    y: (screen_pos.y - rect.y) / rect.height,
  };
}

enum Operator {
  Distance,
  Dot,
  Normalize,
}

struct Operation {
  operator: Operator,
  node: *mut Node,
  operands: List!<*mut Node>,
}

struct Node {
  name: String,
  shape: SolidShape,
  color: Color,
  value: Vector2,
  
  dragging: bool,
}

impl Operation {
  fn draw(*const self) {
    switch self.operator {
      Operator::Distance: {
        if self.operands.length != 1 {
          return;
        }

        operand := self.operands[0];

        node_ss := nodespace_to_screen(self.node.value);
        operand_ss := nodespace_to_screen(operand.value);

        result := self.node.value.distance(operand.value);
        halfway := (node_ss + operand_ss) / 2.0;

        DrawLineV(node_ss, operand_ss, WHITE.with_alpha(60));

        buffer := std::asprintf("Distance(%s,%s)=%.4f", get_global_allocator(), self.node.name.data, operand.name.data, result);
        defer buffer.deinit();

        delta := operand_ss - node_ss;
        angle := atan2(delta.y, delta.x) * (180.0 / PI);
        normal := (Vector2.{ x: -delta.y, y: delta.x }).normalize();
        text_offset := normal * 12.0;
        text_pos := halfway + text_offset;
        text_size := MeasureTextEx(gContext.font, buffer.data, 16, 1);

        DrawTextPro(
          gContext.font,
          buffer.data,
          text_pos,
          Vector2.{ x: text_size.x / 2, y: text_size.y / 2 },
          angle as f32,
          12,
          1,
          ColorLerp(GREEN, WHITE, 0.8)
        );
      }
      Operator::Dot: {
        if self.operands.length != 1 {
          return;
        }

        a := self.node;
        b := self.operands[0];

        result := a.value.dot(b.value);

        a_ss := nodespace_to_screen(a.value);
        b_ss := nodespace_to_screen(b.value);
  
        // Draw both vectors from the same origin (for visualization)
        DrawLineV(a_ss, b_ss, WHITE.with_alpha(40));

        // Draw projection of a onto b
        ab := b_ss - a_ss;
        a_vec := a.value;
        b_vec := b.value;
        b_dir := b_vec.normalize();
        proj_length := a_vec.dot(b_dir);
        proj_vec := b_dir * proj_length;

        // Projected point in world space
        proj_point := a_ss + proj_vec;

        DrawLineV(a_ss, proj_point, BLUE.with_alpha(120));
        DrawCircleV(proj_point, 5, BLUE);

        // Draw annotation
        halfway := (a_ss + proj_point) / 2.0;
        buffer := std::asprintf("Dot(%s,%s)=%.4f", get_global_allocator(), a.name.data, b.name.data, result);
        defer buffer.deinit();

        delta := proj_point - a_ss;
        normal := (Vector2.{ x: -delta.y, y: delta.x }).normalize();
        text_offset := normal * 14.0;
        text_pos := halfway + text_offset;
        text_size := MeasureTextEx(gContext.font, buffer.data, 16, 1);

        DrawTextPro(
          gContext.font,
          buffer.data,
          text_pos,
          Vector2.{ x: text_size.x / 2, y: text_size.y / 2 },
          0.0,
          12,
          1,
          ColorLerp(BLUE, WHITE, 0.8)
        );
      }
      Operator::Normalize: {
        if self.operands.length != 0 {
          return;
        }
      }
    }
  }
}

impl Node {
  fn draw(*mut self) {
    position := nodespace_to_screen(self.value);
    self.shape.draw(position, self.color);


    draw_textf("% (%, %)", 
      (self.name, self.value.x, self.value.y), 
      position + Vector2::scalar(12),
      Style.{ 
        font_size: 12, 
        font: gContext.font, 
      },
      FormatOptions::current().with_digits_after_decimal(4),
    );
  }
}

fn main() {
  SetConfigFlags(ConfigFlags::FLAG_WINDOW_RESIZABLE);
  mut window := Window!<()>::new();
  gContext.font =  LoadFont("assets/FiraCode-Bold.ttf"c);

  gContext.node_list_button_style = .{
    foreground: WHITE,
    background: BLACK.with_alpha(25),
    highlighted: ORANGE,
    line_thickness: 2,
    font_size: 16,
    font_spacing: 1,
    font_color_override: Some(GRAY),
    font: gContext.font,
  };

  mut freeform_area: FreeformArea = .{
    base: .{
      model_rectangle: .{
        x: 0.15,
        y: 0.06666667,
        width: 0.80625,
        height: 0.8666667,
      },
      style: .{
        background: GRAY,
        font: gContext.font,
      }
    }
    screen_to_nodespace: &mut screen_to_nodespace
  };

  freeform_area.base.on_hovered = fn(base: *mut WidgetBase, position: Vector2) {
    for node in gContext.nodes.iter_mut() {
      if node.dragging {
        if !IsMouseButtonDown(MouseButton::MOUSE_BUTTON_RIGHT) {
          node.dragging = false; 
          return;
        }
        node.value = screen_to_nodespace(GetMousePosition());
      }
    }
  };

  freeform_area.base.on_pressed = fn(base: *mut WidgetBase, btn: s32) -> bool {
    mouse_pos := GetMousePosition()
    if btn == MouseButton::MOUSE_BUTTON_RIGHT {
      for node in gContext.nodes.iter_mut() {
        if CheckCollisionPointCircle(nodespace_to_screen(node.value), mouse_pos, 10.0) {
          node.dragging = true;
          break;
        }
      }

    } else {
      nodespace_pos := screen_to_nodespace(mouse_pos);
      for node in gContext.nodes {
        if node.value == nodespace_pos {
          return false;
        }
      }
      #static mut name_idx := 65;
      node := Node.{
        shape: SolidShape::Circle.{ radius: 5.0 }
        value: nodespace_pos,
        color: WHITE,
        name: std::asprintf("%c", get_global_allocator(), name_idx++),
      };
      gContext.nodes.push(node);
      gContext.node_list_ui.add_child(new(Button!<Context>.{
        base: .{
          style: gContext.node_list_button_style,
        }
        on_clicked: fn (ctx: *mut Context) {
          std::printf("we have %d nodes!\n", ctx.nodes.length);
        }
        label: Some(node.name),
        user_arg: &mut gContext,
      }));
    }

    return true;
  };

  mut node_list: ListBox = .{
    base: .{
      model_rectangle: .{
        x: 0.0125,
        y: 0.06666667,
        width: 0.125,
        height: 0.8666667,
      },
      style: .{
        font: gContext.font,
        background: GRAY,
        foreground: WHITE,
      }
    }
  };

  gContext.node_list_ui = &mut node_list;
  gContext.freeform_area = &mut freeform_area;

  window.add_widget(&mut node_list);
  window.add_widget(&mut freeform_area);

  while !WindowShouldClose() {
    BeginDrawing();
    ClearBackground(window.background_color);

    if IsWindowResized() {
      window.on_resized(.{
        x: 0, y: 0,
        width: GetScreenWidth(),
        height: GetScreenHeight(),
      });
    }

    if IsKeyPressed(KeyboardKey::KEY_D)  {
      if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
        gContext.operations.push(.{
          node: &mut gContext.nodes[0],
          operands: List!<*mut Node>::init(.[
            &mut gContext.nodes[1],
          ]),
          operator: Operator::Dot,
        });
      } else {
        gContext.operations.push(.{
          node: &mut gContext.nodes[0],
          operands: List!<*mut Node>::init(.[
            &mut gContext.nodes[1],
          ]),
          operator: Operator::Distance,
        });
      }
    }

    if IsKeyPressed(KeyboardKey::KEY_C) {
      gContext.operations.clear();
      gContext.nodes.clear();
      gContext.node_list_ui.get_children().clear();
    }

    window.widgets.sort(fn(widget: *const dyn Widget) -> u32 {
      return widget.get_base().layer;
    });

    fn handle_events(mouse_position: Vector2, widget: *mut dyn Widget) -> bool {
      base := widget.get_base();
      mut hovered := false;
      mut lmb_pressed := false;
      mut rmb_pressed := false;

      was_pressed := base.input_state & InputState::Pressed;

      base.input_state = InputState::None;
      if CheckCollisionPointRec(mouse_position, base.rectangle) {
        base.input_state = InputState::Hovered;
        hovered = true;

        if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
          base.input_state |= InputState::Pressed;
          lmb_pressed = true;
        }
        if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_RIGHT) {
          base.input_state |= InputState::Pressed;
          rmb_pressed = true;
        }
      }

      children := widget.get_children();
      if children {
        for child in children.iter_mut() {
          if handle_events(mouse_position, child) {
            base.input_state = InputState::None;
          }
        }
      }
    
      if base.input_state & InputState::Hovered && base.on_hovered {
        base.on_hovered(widget.get_base(), mouse_position);
      }

      if was_pressed && base.input_state & InputState::Pressed == 0 && base.on_released {
        // ! THIS IS ALWAYS WRONG
        base.on_released(widget.get_base(), 0);
      }

      if base.input_state & InputState::Pressed && base.on_pressed {
        if lmb_pressed {
          base.on_pressed(widget.get_base(), MouseButton::MOUSE_BUTTON_LEFT);
        }
        if rmb_pressed {
          base.on_pressed(widget.get_base(), MouseButton::MOUSE_BUTTON_RIGHT);
        }
      }

      return hovered || lmb_pressed || rmb_pressed;
    }

    { // Handle events.
      mouse_position := GetMousePosition();
      for widget in window.widgets.iter_mut() {
        handle_events(mouse_position, widget);
      }
    }

    for widget in window.widgets.iter_mut() {
      widget.draw();
    }

    for node in gContext.nodes.iter_mut() {
      node.draw();
    }

    for operation in gContext.operations.iter_mut() {
      operation.draw();
    }

    if !gContext.nodes.is_empty() {
      node := gContext.nodes[0];
      fmt::println(nodespace_to_screen(node.value));
    }


    EndDrawing();
  }

}