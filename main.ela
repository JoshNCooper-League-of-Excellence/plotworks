
#include "ui.ela"

import fmt::*;

struct ListBox {
  base: WidgetBase,
  children: List!<dyn Widget>,
}

impl Widget for ListBox {
  fn draw(*mut self) {
    DrawRectangleRec(self.base.rectangle, self.base.style.background.with_alpha(20));
    DrawRectangleLinesEx(self.base.rectangle, self.base.style.line_thickness, self.base.style.background);
    const MARGIN := 10.0;
    position: Vector2 = .{ x: self.base.rectangle.x, y: self.base.rectangle.y  };
    for child in self.children.iter_mut() {
      base := child.get_base();
      rect := &mut base.rectangle;
      rect.x = position.x + (MARGIN / 2);
      rect.y = position.y + (MARGIN / 2);
      rect.width = self.base.rectangle.width - MARGIN;
      rect.height = (self.base.rectangle.height / self.children.length as f32) - MARGIN;
      position.y += rect.height + MARGIN / 2;
      child.draw();
    }
  }
  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return &mut self.children;
  }
}

impl ListBox {
  fn add_child!<T>(*mut self, widget: *mut T) where T: Widget {
    self.base.children.push(widget.get_base());
    self.children.push(dynof(widget, Widget));
  }
}

struct Node;

enum Operator {
  Distance,
  Dot,
  Normalize,
}

struct Operation {
  operator: Operator,
  node: *mut Node,
  operands: List!<*mut Node>,
}

struct Node {
  name: String,
  shape: SolidShape,
  color: Color,
  value: Vector2,
}

impl Deinit for Node {
  fn deinit(*mut self) {
    self.name.deinit();
  }
}
struct Grid;
struct Context {
  nodes: List!<Node>,
  operations: List!<Operation>,
  node_list_ui: *mut ListBox,
  grid: *mut Grid,
  node_list_button_style: Style,
  font: Font,
}

mut gContext: Context;

fn nodespace_to_screen(grid_value: Vector2) -> Vector2;
fn screen_to_nodespace(screen_pos: Vector2) -> Vector2;

impl Operation {
  fn draw(*const self) {
    switch self.operator {
      Operator::Distance: {
        if self.operands.length != 1 {
          return;
        }

        operand := self.operands[0];

        node_ss := nodespace_to_screen(self.node.value);
        operand_ss := nodespace_to_screen(operand.value);

        result := self.node.value.distance(operand.value);
        halfway := (node_ss + operand_ss) / 2.0;

        DrawLineV(node_ss, operand_ss, WHITE.with_alpha(60));

        buffer := std::asprintf("Distance(%s,%s)=%.2f", get_global_allocator(), self.node.name.data, operand.name.data, result);
        defer buffer.deinit();

        delta := operand_ss - node_ss;
        angle := atan2(delta.y, delta.x) * (180.0 / PI);
        normal := (Vector2.{ x: -delta.y, y: delta.x }).normalize();
        text_offset := normal * 12.0;
        text_pos := halfway + text_offset;
        text_size := MeasureTextEx(gContext.font, buffer.data, 16, 1);

        DrawTextPro(
          gContext.font,
          buffer.data,
          text_pos,
          Vector2.{ x: text_size.x / 2, y: text_size.y / 2 },
          angle as f32,
          12,
          1,
          ColorLerp(GREEN, WHITE, 0.8)
        );
      }
      Operator::Dot: {
        if self.operands.length != 1 {
          return;
        }

        a := self.node;
        b := self.operands[0];

        result := a.value.dot(b.value);

        a_ss := nodespace_to_screen(a.value);
        b_ss := nodespace_to_screen(b.value);
  
        // Draw both vectors from the same origin (for visualization)
        DrawLineV(a_ss, b_ss, WHITE.with_alpha(40));

        // Draw projection of a onto b
        ab := b_ss - a_ss;
        a_vec := a.value;
        b_vec := b.value;
        b_dir := b_vec.normalize();
        proj_length := a_vec.dot(b_dir);
        proj_vec := b_dir * proj_length;

        // Projected point in world space
        proj_point := a_ss + proj_vec;

        DrawLineV(a_ss, proj_point, BLUE.with_alpha(120));
        DrawCircleV(proj_point, 5, BLUE);

        // Draw annotation
        halfway := (a_ss + proj_point) / 2.0;
        buffer := std::asprintf("Dot(%s,%s)=%.2f", get_global_allocator(), a.name.data, b.name.data, result);
        defer buffer.deinit();

        delta := proj_point - a_ss;
        normal := (Vector2.{ x: -delta.y, y: delta.x }).normalize();
        text_offset := normal * 14.0;
        text_pos := halfway + text_offset;
        text_size := MeasureTextEx(gContext.font, buffer.data, 16, 1);

        DrawTextPro(
          gContext.font,
          buffer.data,
          text_pos,
          Vector2.{ x: text_size.x / 2, y: text_size.y / 2 },
          0.0,
          12,
          1,
          ColorLerp(BLUE, WHITE, 0.8)
        );
      }
      Operator::Normalize: {
        if self.operands.length != 0 {
          return;
        }
      }
    }
  }
}


impl Node {
  fn draw(*mut self) {
    position := nodespace_to_screen(self.value);
    self.shape.draw(position, self.color);
    draw_textf("% (%, %)", 
      (self.name, self.value.x, self.value.y), 
      position + Vector2::scalar(12),
      Style.{ 
        font_size: 12, 
        font: gContext.font, 
      }
    );
  }
}

struct Grid {
  base: WidgetBase,
  nodes: List!<Option!<Node>>,
}

impl Widget for Grid {
  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
  fn draw(*mut self) {
    // Draw the grid.
    DrawRectangleLinesEx(self.base.rectangle, self.base.style.line_thickness, self.base.style.background);

    if self.base.input_state & InputState::Hovered {
      mouse := GetMousePosition();

      nodespace_pos := screen_to_nodespace(mouse);

      draw_textf("x=%, y=%", (nodespace_pos.x, nodespace_pos.y), mouse + Vector2::scalar(15), Style.{ font_size: 15, font: gContext.font, font_color_override: Some(WHITE.with_alpha(200))});

      mut shape := SolidShape::Circle.{ radius: 5.0 };
      shape.draw(mouse, WHITE.with_alpha(90));

      if self.base.input_state & InputState::Pressed {

        for node in gContext.nodes {
          if node.value == nodespace_pos {
            return;
          }
        }

        #static mut name_idx := 65;

        node := Node.{
          shape: SolidShape::Circle.{ radius: 5.0 }
          value: nodespace_pos,
          color: WHITE,
          name: std::asprintf("%c", get_global_allocator(), name_idx++),
        };

        gContext.nodes.push(node);

        gContext.node_list_ui.add_child(new(Button!<Context>.{
          base: .{
            style: gContext.node_list_button_style,
          }
          on_clicked: fn (ctx: *mut Context) {
            std::printf("we have %d nodes!\n", ctx.nodes.length);
          }
          label: Some(node.name),
          user_arg: &mut gContext,
        }));

      }
    }
  }
}

fn nodespace_to_screen(node_value: Vector2) -> Vector2 {
  rect := gContext.grid.base.rectangle;
  return Vector2.{
    x: rect.x + node_value.x * rect.width,
    y: rect.y + node_value.y * rect.height,
  };
}

fn screen_to_nodespace(screen_pos: Vector2) -> Vector2 {
  rect := gContext.grid.base.rectangle;
  return Vector2.{
    x: (screen_pos.x - rect.x) / rect.width,
    y: (screen_pos.y - rect.y) / rect.height,
  };
}

fn main() {
  SetConfigFlags(ConfigFlags::FLAG_WINDOW_RESIZABLE);
  mut window := Window!<()>::new();
  gContext.font =  LoadFont("assets/FiraCode-Bold.ttf"c);

  gContext.node_list_button_style = .{
    foreground: WHITE,
    background: BLACK.with_alpha(25),
    highlighted: ORANGE,
    line_thickness: 2,
    font_size: 16,
    font_spacing: 1,
    font_color_override: Some(GRAY),
    font: gContext.font,
  };

  mut grid: Grid = .{
    base: .{
      model_rectangle: .{
        x: 0.15,
        y: 0.06666667,
        width: 0.80625,
        height: 0.8666667,
      },
      style: .{
        background: GRAY,
        font: gContext.font,
      }
    }
  };

  mut node_list: ListBox = .{
    base: .{
      model_rectangle: .{
        x: 0.0125,
        y: 0.06666667,
        width: 0.125,
        height: 0.8666667,
      },
      style: .{
        font: gContext.font,
        background: GRAY,
        foreground: WHITE,
      }
    }
  };

  gContext.node_list_ui = &mut node_list;
  gContext.grid = &mut grid;

  window.add_widget(&mut node_list);
  window.add_widget(&mut grid);

  while !WindowShouldClose() {
    BeginDrawing();
    ClearBackground(window.background_color);

    if IsWindowResized() {
      window.on_resized(.{
        x: 0, y: 0,
        width: GetScreenWidth(),
        height: GetScreenHeight(),
      });
    }

    if IsKeyPressed(KeyboardKey::KEY_D)  {
      if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
        gContext.operations.push(.{
          node: &mut gContext.nodes[0],
          operands: List!<*mut Node>::init(.[
            &mut gContext.nodes[1],
          ]),
          operator: Operator::Dot,
        });
      } else {
        gContext.operations.push(.{
          node: &mut gContext.nodes[0],
          operands: List!<*mut Node>::init(.[
            &mut gContext.nodes[1],
          ]),
          operator: Operator::Distance,
        });
      }
    }

    if IsKeyPressed(KeyboardKey::KEY_C) {
      gContext.operations.clear();
      gContext.nodes.clear();
      gContext.node_list_ui.get_children().clear();
    }

    window.widgets.sort(fn(widget: *const dyn Widget) -> u32 {
      return widget.get_base().layer;
    });

    fn handle_events(mouse_position: Vector2, widget: *mut dyn Widget) -> bool {
      base := widget.get_base();
      mut handled := false;

      base.input_state = InputState::None;
      if CheckCollisionPointRec(mouse_position, base.rectangle) {
        base.input_state = InputState::Hovered;
        handled = true;

        if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
          base.input_state |= InputState::Pressed;
        }
      }

      children := widget.get_children();
      if children {
        for child in children.iter_mut() {
          if handle_events(mouse_position, child) {
            base.input_state = InputState::None;
          }
        }
      }

      return handled;
    }

    { // Handle events.
      mouse_position := GetMousePosition();
      for widget in window.widgets.iter_mut() {
        handle_events(mouse_position, widget);
      }
    }

    for widget in window.widgets.iter_mut() {
      widget.draw();
    }

    for node in gContext.nodes.iter_mut() {
      node.draw();
    }

    for operation in gContext.operations.iter_mut() {
      operation.draw();
    }

    if !gContext.nodes.is_empty() {
      node := gContext.nodes[0];
      fmt::println(nodespace_to_screen(node.value));
    }


    EndDrawing();
  }

}